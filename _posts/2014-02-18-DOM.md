---
layout: post
title: (study)DOM을 깨우치다
categories: [javascript]
tags: [javascript, dom]
fullview: false
---

> study book : DOM을 깨우치다:가치에 대한 완전한 이해  
> 저자 : 코디 린들리  
> 역자 : 안재우  

1. [노드 개요](#chapter1)  
1. [Document 노드](#chapter2)  

##<a href="#" name="chapter1">노드 개요</a>  
브라우저는 HTML 코드를 해서해서 트리 형태로 구조화된 노드들을 가지고 있는 문서(DOM)를 생성한다.  
DOM의 목적은 JavaScript를 사용해서 이 문서에 대한 스크립트 작성(삭제, 추가, 바꾸기, 이벤트 처리, 수정)을 위한  
프로그래밍 인터페이스를 제공하는 것이다.  

- 노드 개체 유형  
    + DOCUMENT_NODE (예 : window.document)  
    + ELEMENT_NODE (예 : `<body>`, `<p>` 등)  
    + ATTRIBUTE_NODE (예 : class="attr")  
    + TEXT_NODE (예 : 줄바꿈과 공백을 포함한 HTML 문서 내의 텍스트 문자)  
    + DOCUMENT_FRAGMENT_NODE (예 : document.createDocumentFragment())  
    + DOCUMENT_TYPE_NODE (예 : `<!DOCTYPE html>`)  

- nodeType  
    + ELEMENT_NODE = 1  
    + ATTRIBUTE_NOE = 2  
    + TEXT_NODE = 3  
    + CDATA_SECTION_NODE = 4  
    + ENTITY_REFERENCE_NODE = 5  
    + ENTITY_NODE = 6  
    + PROCESSING_INSTRUCTION_NODE = 7  
    + COMMENT_NODE = 8  
    + DOCUMENT_NODE = 9  
    + DOCUMENT_TYPE_NODE = 10  
    + DOCUMENT_FRAGMENT_NODE = 11  
    + NOTATION_NODE = 12  
    + DOCUMENT_POSITION_DISCONNECTED = 1  
    + DOCUMENT_POSITION_PRECENDING = 2  
    + DOCUMENT_POSITION_FOLLOWING = 4  
    + DOCUMENT_POSITION_CONTAINS = 8  
    + DOCUMENT_POSITION_CONTAONED_BY = 16  
    + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32  
    
`ATTRIBUTE_NODE는 DOM4에서 사용이 금지 되었다.`  
`getAttribute(), setAttribute(), removeAttribute() 메서드를 활용할 수 있다.`  

###노드의 유형과 이름 식별하기  
    
    <a href="#">anchor</a>
    <script>
        console.log(document.nodeName, document.nodeType);  // #document, 9
        console.log(document.doctype.nodeName, document.doctype.nodeType);  // <!DOCTYPE html>, 10
        console.log(document.createDocumentFragment().nodeName, document.createDocumentFragment().nodeType);  // #document-fragment, 11
        console.log(document.querySelector('a').nodeName, document.querySelector('a').nodeType);  // A, 1
        console.log(document.querySelector('a').firstChild.nodeName, document.querySelector('a').firstChild.nodeType);  // anchor, 3
    </script>
    
###노드 값 가져오기  
nodeValue 속성은 Text와 Comment를 제외한 대부분 노드 유형에서는 null 값을 반환한다.  
    
    <a href="#">anchor</a>
    <script>
        console.log(document.nodeValue);  // null
        console.log(document.doctype.nodeValue);  // null
        console.log(document.createDocumentFragment().nodeValue);  // null
        console.log(document.querySelector('a').nodeValue);  // null
        console.log(document.querySelector('a').firstChild.nodeValue);  // anchor
    </script>
    
###JavaScript 메서드를 사용해서 Element 및 Text 노드를 생성하기  

- createElement()  
- createTextNode()  

    var elAddDiv = document.createElement('div');
    console.log(elAddDiv, elAddDiv.nodeType);  // `<div></div>`, 1
    
    var sTextNode = document.createTextNode('Hi');
    console.log(sTextNode, sTextNode.nodeType);  // Hi, 3
    
###JavaScript 문자열을 사용하여 DOM에 Element 및 Text 노드를 생성 및 추가하기  

- innerHTML  
- outerHTML  
- textContent  
- innerText(비표준 확장)  
- outerText(비표준 확장)  
- insertAdjacentHTML  
`.`
    
    <div id="divA">divA</div>
    <div id="divB">divB</div>
    <div id="divC">divC</div>
    <div id="divD">divD</div>
    <div id="divE">divE</div>
    <div id="divF">divF</div>
    
    <script>
        document.getElementById('divA').innerHTML = '<strong>innerHTML</strong>';  // <div id=divA><strong>innerHTML</strong></div>
        document.getElementById('divB').outerHTML = '<div><a href="#">anchor</a></div>';  // <div><a href="#">anchor</a></div>
        document.getElementById('divC').textContent = 'textContent';  // <div id="divC">textContent</div>
        document.getElementById('divD').innerText = 'innerText';  // <div id=divD>innerText</div> => 비표준 확장
        document.getElementById('divE').outerText = 'outerText';  // outerText => 비표준 확장
        
        var elDiv = document.getElementById('divF');
        elDiv.insertAdjacentHTML('beforebegin', '<a href="#">beforebegin</a>');  // <a href="#">beforebegin</a><div id="divF">divF</div>
        elDiv.insertAdjacentHTML('afterbegin', '<a href="#">afterbegin</a>');  // <div id="divF"><a href="#">afterbegin</a>divF</div>
        elDiv.insertAdjacentHTML('beforeend', '<a href="#">beforeend</a>');  // <div id="divF">divF<a href="#">beforeend</a></div>
        elDiv.insertAdjacentHTML('afterend', '<a href="#">afterend</a>');  // <div id="divF">divF</div><a href="#">afterend</a>
    </script>
    
`innerHTML` 속성은 문자열 내에서 발견된 HTML 요소를 실제 DOM 노드로 변환하는 반면, `textContent`는 텍스트 노드를 생성하는 데만 사용 가능하다.  

###appendChild() 및 insertBefore()를 사용하여 노드 개체를 DOM에 추가하기  
appendChild() 및 insertBefore() 노드 메서드는 JavaScript 노드 개체를 DOM 트리에 삽입할 수 있게 해준다.  

- appendChild()  
- insertBefore()  
`.`
    
    <ul>
        <li>list2</li>
        <li>list3</li>
    </ul>
    <script>
        var elLi = document.createElement('li');
        var sText = document.createTextNode('list1');
        var elUl = document.querySelector('ul');
        elUl.insertBefore(elLi, elUl.firstChild);
        
        /*
        <ul>
            <li>list1</li>
            <li>list2</li>
            <li>list3</li>
        </ul>
        */
    </script>
    
###removeChild() 및 replaceChild()를 사용하여 노드를 제거하거나 바꾸기  

- removeChild()  
- replaceChild()  

먼저 삭제하고자 하는 노드를 선택해야 한다.  
다음으로 부모 노드에 대한 접근을 얻어야 하는데, 보통 parentNode 속성을 사용하게 된다.  
    
    <div id="divA">divA</div>
    <div id="divB">divB</div>
    <div id="divC">divC</div>
    <div id="divD">divD</div>
    <script>
        var elA = document.getElementById('divA');
        var elB = document.getElementById('divB').firstChild;
        var elC = document.getElementById('divC');
        var elD = document.getElementById('divD').firstChild;
        var sText = document.createTextNode('add text');
        var elSpan = document.createElement('span');
        elSpan.textContent = 'add span';
        
        elA.parentNode.removeChild(elA);
        elB.parentNode.removeChild(elB);
        elC.parentNode.replaceChild(elSpan, elC);
        elD.parentNode.replaceChild(sText, elD);
        
        console.log(document.body.innerHTML);
        /*
        <div id="divB"></div>
        <span>add span</span>
        <div id="divD">add text</div>
        */
    </script>
    
> removeChild(), replaceChild()는 각각 교체되거나 제거된 노드를 반환한다.  
> 기본적으로 해당 노드는 바꾸거나 제거하는 것이므로 사라지지 않았다.  
> 이 동작은 해당 노드가 현재 문서의 범위를 벗어나게 만든다.  
> 해당 노드에 대한 메모리상의 참조는 여전히 가지게 된다.  

###cloneNode()를 사용하여 노드를 복제하기  
cloneNode() 메서드를 사용하여 단일 노드 혹은 노드 및 모든 자식 노드를 복제할 수 있다.  
    
    <ul>
        <li>list1</li>
        <li>list2</li>
    </ul>
    <script>
        var cloneUl = document.querySelector('ul');
        cloneUl.cloneNode(true);
        console.log(cloneUl.constructor);  // function HTMLUListElement() { [native code] }
        console.log(cloneUl.innerHTML);
        /*
        <li>list1</li>
        <li>list2</li>
        */
    </script>
    
> Element 노드를 복제할 때, 모든 특성 및 값(인라인 이벤트 포함)도 복제된다.  
> addEventListener()나 node.onclick으로 추가된 것은 복제되지 않는다.  

###직계 자식 노드 전부에 대한 리스트/컬렉션 얻기  
childNodes 속성을 사용하면 직계 자식 노드에 대해 배열 형태의 리스트(예 : NodeList)가 나온다.  
    
    <ul>
        <li>list1</li>
        <li>list2</li>
    </ul>
    <script>
        var elUl = document.querySelector('ul').childNodes;
        console.log(elUl);  // [text, li, text, li, text, item: function] => ul 내의 전체 노드로 이루어진 유사 배열 리스트를 출력, 진정한 배열은 아니다.
        
        Array.prototype.forEach.call(elUl, function(item){
            console.log(item);
            /*
            #text
            <li>list1</li>
            #text
            <li>list2</li>
            #text
            */
        });
    </script>
    
###NodeList나 HTMLCollection을 JavaScript 배열로 변환  
NodeList나 HTMLCollection은 배열 형태이지만, array의 메서드를 상속하는 진정한 JavaScript 배열은 아니다.  
    
    <a href="#">anchor</a>
    <script>
        console.log(Array.isArray(document.links));  // HTMLCollection이지 Array가 아니므로 false가 반환된다.
        console.log(Array.isArray(document.querySelectorAll('a')));  // NodeList이지 Array가 아니므로 false가 반환된다.
    </script>
    
NodeList나 HTMLCollection을 진정한 JavaScript 배열로 변환하는 것은 몇 가지 이점을 가져다 준다.  
Array 개체가 제공하는 메서드들(예 : forEach, pop, map, reduce 등)에 접근할 수 있게 된다.  
유사 배열 리스트를 진정한 JavaScript 배열로 변환하기 위해  
`.call()` 혹은 `apply()`에 유사 배열 리스트를 전달하면 배열을 반환하는 메서드를 호출한다.  
`slice()` 메서드가 배열을 반환하므로 배열로 변환하는데 활용 가능하다.  
    
    <a href="#">anchor</a>
    <script>
        console.log(Array.isArray(Array.prototype.slice.call(document.links)));  // true
        console.log(Array.isArray(Array.prototype.slice.call(document.querySelectorAll('a'))));  // true
    </script>
    
###DOM 내의 노드 탐색  

- element 노드뿐만 아니라 text와 comment 노드도 포함  
    + parentNode  
    + firstChild  
    + lastChild  
    + nextSibling  
    + previousSibling  
    
- text와 comment 무시하고 DOM 탐색  
    + parentElement  
    + firstElementChild  
    + lastElementChild  
    + nextElementSibling  
    + previousElementSibling  
    + children  
    
`childElementCount`는 노드가 가지고 있는 자식 element의 개수를 계산할 때 유용한 속성이다.  
    
    <ul><!-- comment -->
        <li id="listA">listA</li>
        <li id="listB">listB</li><!-- comment listB -->
        <!-- comment -->
    </ul>
    <script>
        var elUl = document.querySelector('ul');
    
        console.log(elUl.parentNode.nodeName);  // body
        console.log(elUl.firstChild.nodeName);  // #comment
        console.log(elUl.lastChild.nodeName);  // #text => 줄바꿈 영향
        console.log(elUl.querySelector('#listA').nextSibling.nodeName);  // #text
        console.log(elUl.querySelector('#listB').nextSibling.nodeName);  // #comment
        console.log(elUl.querySelector('#listB').previousSibling.nodeName);  // #text
        
        console.log(elUl.firstElementChild.parentElement);
        /*
        <ul><!-- comment -->
            <li id="listA">listA</li>
            <li id="listB">listA</li><!-- comment listB -->
            <!-- comment -->
        </ul>
        */
        console.log(elUl.firstElementChild.nodeName);  // li
        console.log(elUl.lastElementChild.nodeName);  // li
        console.log(elUl.querySelector('#listA').nextElementSibling.nodeName);  // li
        console.log(elUl.querySelector('#listB').previousElementSibling.nodeName);  // li
        console.log(elUl.children[0]);  // <li id="listA">listA</li>
    </script>
    
###contains()와 compareDocumentPosition()으로 DOM 트리 내의 Node 위치를 확인하기  
    
    <ul>
        <li id="listA">listA</li>
        <li id="listB">listB</li>
    </ul>
    <script>
        var elUl = document.querySelector('ul');
        console.log(document.querySelector('html').contains(elUl));
    </script>
    
###두 노드가 동일한지 판단하기  

- 두 노드가 동일한 형식이다.  
- nodeName, localName, namespaceURI, prefix, nodeValue 문자열 특성이 동일하다.  
    즉, 둘 다 null 이거나, 동일한 길이와 동일한 문자를 가져야 한다.  
- NameNodeMaps 특성이 동일하다. 즉 둘 다 null 이거나 길이가 동일해야 하며, 하나의  
    앱 내에 존재하는 각 노드들과 다른 맵에 존재하는 노드가 동일해야 하되 인덱스가 동일할 필요는 없다.  
- childNode, NodeLists가 동일하다. 즉 둘 다 null 이거나, 동일한 길이를 가지고 같은 인덱스의 노드가  
    동일해야 한다.  정규화(normalization)가 동일성에 영향을 미칠 수 있으므로, 이를 피하기 위해서는  
    비교를 수행하기 전에 노드를 정규화해야 한다.  
`.`
    
    <ul>
        <li class="listA">listA</li>
        <li class="listB">listA</li>
        <li class="listA">listA</li>
    </ul>
    <script>
        var elLi = document.querySelectorAll('li');
        console.log(elLi[0].isEqualNode(elLi[1]));  // false
        console.log(elLi[0].isEqualNode(elLi[2]));  // true
    </script>
    
##<a href="#" name="chapter2">Document 노드</a>  

###일반적인 HTML 문서 정보 얻기  

- document.title  
- document.URL  
- document.referrer  
- document.lastModified  
- document.compatMode  
`.`

    console.log(document.title);
    console.log(document.URL);
    console.log(document.referrer);
    console.log(document.lastModified);
    console.log(document.compatMode);  // BackCompat(Quirks 모드) 또는 CSS1Compat(Strict 모드) 중 하나가 출력된다.
    
